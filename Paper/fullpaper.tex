\documentclass{IEEEtran}

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
%\usepackage{geometry}
%\geometry{letterpaper}
%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.



\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{url}
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{algorithm} 
\usepackage{algorithmic}
\usepackage{amsmath}



% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
%\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
%\pagestyle{fancy} % options: empty , plain , fancy
%\renewcommand{\headrulewidth}{0pt} % customise the layout...
%\lhead{}\chead{}\rhead{}
%\lfoot{}\cfoot{\thepage}\rfoot{}

%%% END Article customizations

%%% The "real" document content comes below...

\title{VHash: An Optimized Voronoi-Based Distributed Hash Table }
\author{Double Blind}
%\author{Brendan Benshoof \qquad Andrew Rosen  \\Department of Computer Science, Georgia State University\\  bbenshoof@cs.gsu.edu \qquad rosen@cs.gsu.edu }
\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\begin{abstract}
%1. State the problem
Distributed Hash Tables (DHT) provide a fast and robust decentralized means of key-value storage and retrieval and are typically used in Peer-to-Peer applications.
DHTs assign nodes a single identifier derived from the hash of their IP address and port, which results in a random overlay network.   
%2. Say why itâ€™s an interesting problem
A random overlay network is not explicitly optimized for certain metrics, such as latency, trust, energy, or hops on an overlay network.  It is often desirable to generate an overlay network that is optimized for one or more specific metrics.

%3. Say what your solution achieves
This paper presents VHash, a DHT protocol to construct an overlay optimized for such metrics. 
VHash exploits a fast and efficient Delaunay Triangulation heuristic in a geometric space. 
%4. Say what follows from your solution
We used VHash to generate an overlay with edges that minimize latency. 
While we focused on latency in this paper, VHash optimizes on any defined metrics.
This overlay outperformed an overlay generated by the Chord DHT protocol in terms of lookup time.
VHash provides a robust, scalable, and efficient distributed lookup service.

\end{abstract}
%  We could use a different config 
% networks are only hpped
% we can do non-euclidean metrics if we have a non-euclidean distance and midpoint definition

\section{Introduction}
A Distributed Hash Table is used provide an overlay network for many P2P applications. %State of the art DHT techniques are built on trees or ring structures to ensure that the routing distance is $O(lg(n))$ hops between nodes. 
%keep?
%In the vast majority of Distributed Hash Tables, such as Chord \cite{chord}, Kademlia\cite{kademlia}, Pastry \cite{pastry}, a node is mapped key on a 1-dimensional keyspace.  This key is chosen via a hash function, such as SHA-1, ensuring that nodes are randomly and uniformly the overlay network.
%keep?
%This provides the network with load balancing properties.  Since files are assigned keys in a similar manner to nodes, the node are distributed evenly ac.  The distribution also provides fault tolerance;  if all the nodes located in a real geographic region were suddenly taken offline, the damage to the network would be spread uniformly throughout the network and maintenance would repair the damage.%
Each node in the overlay network maintains a routing table of a subset of other nodes in the overlay.  
The configuration and rules of the routing table vary from one protocol and another;  the entries of the table might be separated by powers of 2 \cite{Chord}, be determined by shared prefixes \cite{pastry}, or be chosen according to a probabilistic distribution \cite{kleinberg2000navigation}, but the goal is to minimize the number of overlay hops the distributed lookup needs to make. 


%The ``problem''
%This is the correct choice make if there is no other information to act on during lookup or routing. 
A routing table created to minimize overlay hops does exactly that; it does not necessarily create routes with minimized latency.  However, what if more information about the nodes could be encoded as part of the overlay, such as the node's latency or energy?  We wanted to design an overlay where network metrics, such as inter-node latency, node energy levels, or non-euclidean metrics like trust could be embedded in the network.  The most straightforward way is to assign each network metric to a node as a coordinate in a space with the hashed key treated as an additional coordinate.   If each node is defined as object in this space, we can then use a distance function to choose the shortest path over these metrics.


This opens up two problems:  how do we generate an multidimensional overlay that incorporates network metrics as part of routing and how do we generate the coordinates that correspond to the network metrics?
We present VHash as our solution to these problems.


VHash is a DHT designed to take inter-node latency information into account when generating an overlay, although other network metrics could easily be applied.  VHash creates an approximation of a Voronoi network and Delaunay Triangulation to define the routing tables and dictate where content is stored in the network.  We accomplish this by assigning each node $d$ coordinates, rather than than a single key.  We use a basic spring model to embed inter-node latency graph in the overlay. A result of this is that nodes in VHash  can \emph{move} along an axis;  their position is not nessarily fixed.
Our paper presents the following:
\begin{itemize}
	\item We describe the VHash protocol (Section II) and the underlying approximation algorithm of overlay's Delaunay Trinangulation and the corresponding Voronoi diagrams.   Our approximation is distributed, greedy, efficient, and accurate in arbitrary number of dimensions and creates an overlay with edges that minimize distance over network metrics while maintaining robustness, scalablilty, and polylogarithmic lookup time in overlay hops.
	\item We use VHash to provide us with an overlay for embedding network metrics, our other innovation.  We present our basic spring model for embedding nodes in the overlay with latency information and discuss other network metrics that can be used with VHash (Section III).
	\item We created simulations (Section IV) to prove that the overlays created by VHash are accurate enough for routing messages from arbitrary source nodes to random destination locations.  We also show that by embedding the latency graph, our routing dramatically outperforms Chord (and by extension, other overlays with $\lg(n)$-sized routing tables) in terms of latency.
	\item We compare the VHash protocol to the other protocols that are based off of Voronoi region approximation.  We also contrast the properties of VHash with well known extant protocols.
	\item We discuss future work that follows from our what plans we have for embedding different problems using VHash.
\end{itemize}


\section{VHash}
Nodes in the VHash network periodically gossip with other nodes, exchanging information about theirs peers and use the approximation algorithm to refine its list of neighbors.
These neighbors approximate the node's Voronoi region and it's corresponding responsibilities.
This approximation algorithm is fast and can be used for spaces with an arbitrary number of dimensions.

\subsection{Voronoi Regions in DHTs}
A Voronoi diagram is the division of a $d$-dimensional space into cells or regions along a set of objects $O$ such that all the points in a particular region are closer to one object than any the object.  
We refer to the region owned by an object as that object's Voronoi region.
The Delaunay Trangulation of this same space along the same set of objects is defined by the edges such that no object is inside the circumcircle of any triangle formed by the edges\cite{geoalg}.  
The Voronoi diagram and Delaunay Triangulation are dual problems, as an edge between two objects in a Delaunay Triangulation exists iff those object's Voronoi region border each other.  
This means that solving either problem will yield the solution to both. 

In our network, the nodes are the objects of the Voronoi diagram and their regions define the keyspace they are responsible for.  The edges created by the Deluanay Triangulation correspond to the connections between neighboring nodes.  However, computing Voronoi diagrams is expensive, but a greedy approximation of the Voronoi regions is sufficient for the protocol.  We created a new greedy, online algorithm that approximates and maintains the set of peers defining the node's Voronoi region and Delaunay Triangulation.

A formal and thorough description of Voronoi diagrams as well as their applications can be found in \cite{aurenhammer1991voronoi}.

Arguably all DHTs are built on the concept of Vornoi regions. In all DHT's currently contrived, a node is responsible for all points in it's hash space to which it is the ``closest'' node. These DHTs have carefully chosen metric spaces such that these regions are very simple to calculate. For example Chord and similar ring based DHTs utilize a unidirectional one dimensional ring as thier metric space, such that the region for which a node is responsible is the region between it and it's predecessor. Similar transformations of DHT mechanisms into metric spaces can be preformed for other DHTs. VHash generalizes these behavoirs such that by choosing a particular metric space VHash approximates other DHTs. The toroidal metric space utilized in this paper is an extension of the ring topology into additional dimensions. 

The cost of generalizing VHash to utilize any metric space is the efficency of calculating vornoi regions. It is prohbitively expensive to generate an exact calculation of the delunay peers and vornoi regions of a metric space in a distributed fashion\cite{raynet}%\footnote{They cite Geometric Algorithms by Boissonat}. 
This caculation becomes more prohibitvely expense as the number of dimensions increases. Previous explorations into distributed approximations of node's voronoi regions (ray-net) offer constant time approximations. However the monte-carlo techniques applied hide cost of calculation in large sampling sizes. We utilize a greedy heuristic that requires a similar computation cost of a single sample from ray-net's monte-carlo approximation. As a heuristic, there exist edge cases where it is incorrect. We mitigate this issue in our peer selection however it is imporant to note that the hit-rate of VHash approaches 1.0 asymtotically over time. We show in the experimental section that this loss in accuracy has negligable impact on use and is likely to be smaller than the impact of churn upon the hit-rate.

\subsection{Distributed Greedy Voronoi Heuristic}
The Distributed Greedy Voronoi Heuristic (ALGORITHM XYZ) is a fast method for nodes to select peers from thier Delunay Triangulation. It is predicated on the assumption that the midpoint between two nodes falls on the line segment that they share on the edges of thier voronoi regions. Which holds true in the vast majority of cases.

Each cycle, nodes exchange their peerlists with their current neighbors and then recalculate their neighbors.  
The calculation is straightforward.
After a node receives it's neighbor's peerlists, it combines their peerlists and its own into a list of candidate neighbors, sorted the nodes by distance from closest to furthest.
A new peerlist is then created starting with the first candidate from the list of candidates.
The node then looks at each of the remaining candidates and calculates the midpoint between the node and the candidate.
If any of the nodes in the new peerlist are closer to the midpoint than the canidate, the candidate is set aside.  Otherwise the candidate is added to the new peerlist.

This heuristic has the benefit of being fast and scalable into any metric space where a distance function and midpoint can be defined.
The distance metric used for this paper is the minimum distance in a multidimensional toroidal space, where iven two vector locations $\vec{a}$ and $\vec{b}$ on a $d$ dimensional unit toroidal hypercube, the distance between them is: %reference a formula 
\[  \sqrt{\sum\limits_{i\in d} (\min(|\vec{a}_i-\vec{b}_i|, 1.0-|\vec{a}_i-\vec{b}_i|))^2}\]



As mentioned in earlier discussion, this heuristic can fail. Should an ``occluding'' node be positioned such that the midpoint between two nodes does not fall upon the shared face of thier voronoi regions then this heustic will not link the occluded peers. %picture
This is mitigated by our method of peer managment.


\subsection{Fast Vornoi Classifier}
VHash never actually calculates the polytopes that describe a node's vornoi region.
This is unnecessary and prohibitively expensive \cite{raynet}.
Rather VHash only ever assigns a given point to a vornoi region.
It does this by calculating the distance from that point to all canidate nodes.
The point falls into a node's voronoi region if it is the node to which it has the shortest distance.
Thus a node defines it's voronoi region by keeping a list of the peers that bound it.
The cost of this calculation is identical to the cost of testing if a point is within a polytope, without the inital cost of generating that polytope.

\subsection{Peer Management}
VHash maintains two peer lists: Short Peers and Long Peers.
This is motivated by mitigating the error induced by the Distributed Greedy Voronoi Heuristic and providing robustness during churn.

Short Peers are the subset of the Delunay Peers generated by the Distributed Greedy Voronoi Heuristic. 
The number of short peers has no upper bound and in contrived cases it can grow quite high. However in uncontrived networks the expected maximum number of short peers is $\Theta(\frac{\log N}{\log \log N} )$ \cite{bern1991expected}.
We found through experimentation that the expression $2 \cdot \frac{\log N}{\log \log N} + d$ was effective as  minimum length of the short peer list.
An approximation of the number of nodes in the network is sufficient to generate an accurate expected number of short peers.  
This expected number of short peers is used as the lower bound for the size of short peer list.
Should the number of short peers generated by the Distributed Greedy Voronoi Heuristic be less than the lower bound for that set's size, the nearest peers not already included in the short peer list are added to the short peer list until it is of sufficient size.
Short peers are analogous to the predecessors/successors in other DHTs.

Long Peers correspond to the two hop peers of the node.
When a node learns about potential neighbors, but are not included in the short peer list, they may be included in the long peer list.  
The long peer list has a maximum size of the base length of the short peer list squared.  
For example, if the short peer list has a minimum size of 8, the long peer list has a maximum size of 64 entries.  
Long peers are not actively probed during maintenence and the cost of managing them is minimal.
 
We discuss how nodes learn about short and long peers in the Gossiping subsection.


\subsection{Maintenance via Gossiping}
Each node in the network performs maintenance periodically by `gossiping' with a randomly chosen neighbor.
When two nodes gossip with each other, they exchange their short peer lists with each other.
The node combines the lists of short peers\footnote{Naturally, nodes remove themselves and repitions from the candidates.} and uses the  Distributed Greedy Voronoi Heuristic to determine which of these candidates correspond to its neighbors along the Delaunay Triangulation.
The candidates determined not to be short peers become long peers.  
If resulting number of long peers exceeds the maximum size of the long peer list, a random subset of the maximum size is kept.

The formal algorithm for this process is described by Algorithms \ref{maint} and \ref{handlemaint}. This maintenance through gossip process is very similar to the gossip protocol used in \cite{raynet}.


\subsection{Handling Churn}
Churn is effects of the continous joining and exiting of nodes in the overlay.
DHTs must have some mechanisms to handle this process to maintain fault tolerance and routing.

Joining the network is a straightforward process.  
A prospective node must be able to communicate with at least one patron member of the DHT.  
The prospective node is assigned a location using one of the methods described in Section III and uses the patron it knows to find node responsible for its assigned location, which we call the parent.
The prospective node sets the parent node as the lone member of the short peers and immediately gossips with the parent.  Subsequent gossips will refine the peer lists of the nodes affected by the join.

There is no ``polite'' exit from the network. VHash assumes nodes will fail and the difference between an intended failure and unintended failure is unnecessary. 
Suppose a node $f$ fails or leaves the network; we assume it does so abruptly and without warning.
When one of $f$'s neighbors attempts to contact $f$ for gossiping or routing, failure to communicate with $f$ will prompt the neighbor to remove $f$ from its peers.  
The node the selects a different neighbor to gossip with or recomputes the peer closest to the location it was looking for, in the case of routing. 
Should a short peer fail, routing around its failure is trivial due to knowledge about the long peers.  The failure of a long peers is of no consequence because of the existance of the short peers, which provide for routing in that direction.

\subsection{Routing}
The proper forwarding peer for routing a message extends from the voronoi regions of the short peers and long peers.
Rather than attempt to know the true voronoi region of those peers we approximate the voronoi regions of those peers as if there where no other nodes in the network.
The resulting voronoi regions describe both the subset of the network for which that peer is responsible and the subset of the network for which it is the most efficent forwarding node.
The routing node determines the vornoi region into which the message's destination falls.
If this is itself, it handles the message accordingly; otherwise the routing node forwards the message to the responsible node.
This process is equivalent to a pre-computed and cached efficient routing algorithm.
Even if our approximation for the Voronoi region of a peer is incorrect due to incomplete knowledge of the network, our approximation describes the most efficient forwarding path of a message  destined for that space availible.




\subsection{Algorithm Analysis}
The Distributed Greedy Voronoi Heuristic is very efficient in both terms of space and time.  Suppose a node is creating its short peer list from $k$ candidates.  The candidates must be sorted, which takes $O(k\cdot\lg(k))$ operations.  Then for each candidate, that the node must compute the midpoint between itself and the current candidate and then compare distances to that point between itself and all of the peers it has found so far.  This comes down to a cost of 

\[ k\cdot\lg(k) + k \text{ midpoint computations}  + k^{2} \text{ distance computations} \]


Since  $k$ is  bounded by $\Theta(\frac{\log N}{\log \log N} )$  (the maximum number of unique stored neighbors allowed between two neighbors), we can translate the above to

\[\Theta(\frac{\log^{2} N}{\log^{2} \log N} )\]

While previous work \cite{raynet} claims constant time approximation, the reality is that Raynet's leading constant is in the order of thousands of Monte-Carlo samples.  
The number of Monte-Carlo samples used by Raynet will need to be increased as the number of dimensions and nodes in the Raynet's overlay increases.  The Distributed Greedy Voronoi Heuristic doesn't need to take samples and it's full cost is expressed in the above equations.  

Our algorithm can be adjusted to run in constant time if the size of the short peer list is arbitrarily bounded at a constant based off the dimension, but this comes with the cost of convergence to reliable lookups as the size of the overlay increases.



\section{Network Metric Embedding}

The VHash Space's flexible metric allows application of the network to solving routing issues.
Rather than be limited to the current ring-based metric, we intend to apply VHash to generating efficent routing and storage to a variety of applications.
Becuase information about a node can be encoded into a cordinate system we can encode an efficent routing scheme into the topological nowledge of the nodes in the network combined with the destination address.

By utilizing specific metric spaces we can design a generalized and fast model for a routing scheme in multiple sinarios.
For example, if VHash is used on a terrestrial Radio based network, recording latitude, logitude, altitude, and power levels allow distance between radios to be interpreted in terms of an approximation of signal strength rather than attempting to use eclidian distance as the distance metric.

Any metric space where inter-node distance and the midpoint between two nodes can be calculated efficently can utilize VHash's Distributed Greedy Voronoi Heuristic or ray-net's volume approximation heuristic should the preformance versus accuracy tradeoff be worthwhile.

VHash's interchangeable metric space is intended to allow applications of DHTs to areas of networking where DHT's preformance limitations previously prevented application.
Any routing scheme that can be described in a metric space where the ideal path on the network is approximated by a direct path in the metric space can be utilized by VHash.


Two types of information encoding are immediately apparent for use in VHashs: The usage of scalar values as indiviual axies and the embedding of a graph topology into an arbitrary number of dimensions.

As there has been no need for a distributed algorithim for graph embedding where each node represents a node in the graph we propose an inital naive approximation method based on Force-directed graph drawing \cite{Spring}.
The algorithim utilizes VHash's maintence and join bevhavoirs.

As a node joins the VHash network for the first time it is assigned a random location in the toroidal metric space.
It joins the network and discovers an inital set of peers.
The node sends ping messages to each of it's peers to approximate latency.
The node calculates an ideal distance to each peer based on latency.
For each peer the node generates an error vector that would place the node at the idea distance.
These error vectors added to the node's current cordiantes and the node uses the result as a new location.
The node attempts to rejoin the network at this new location. Should the node's joining parent be it'self then the node changes the location it advertises to it's peers.
After a sufficent number of cycles nodes will find stable locations.
The approximation is an online algorithim and should be periodically re-applied to account for changes due to churn and congestion.




%While encoding latitude and logitude as locations and using distance across the earth's surface as the distance metric may provide an approximation of a minmum latency overlay topology, this method cannot be used in more general network sinarios and may not describe the actual lowest latency path.

In the experimental section we preform an online distributed approximation of embedding the inter-node latency graph onto a two dimensional toroidal plane and use the resulting cordiantes in VHash to generate an approximate minimum latency overlay network. 


\section{Simulations}
Scale free networks are internet shaped\cite{cohen2000resilience}

We implemented two experimental tests to prove that VHash acts as as a stable DHT and is able to minimize the latency on lookup time.
While we have implemented functional software versions of the protocol, it was more economical to simulate VHash behavoir in a centralized fashion for these experiments.
First, we simulate hit-rate over time as a VHash network is established from a random graph.
Second we compare the distributions of latency in Vhash and Chord DHTs to examine benefits from optimizing the network topology for minimum latency.

% Routing convergence tests
\subsection{Convergence Simulation}
As proof that the VHash protocol converges to a stable overlay from an inclement starting topology, we simulate the hit-rate of the network as the network as the protocol builds a topology from an initally random starting network.
We compare these results to RayNet, which preformed similar experiements to demonstrate fast self organizing behavoir.

RayNet proposed that a random k-connected graph would be a good demonstration of convergance for a DHT.
To generate this graph Raynet, for the first two generations, added 10 randomly selected nodes to the peerlist of each node.
Then the network's hit rate is sampled and recorded.
Hit rate of the network is calculated by taking taking 2000 samples as follows:
\begin{enumerate}
            \item{Choose a node N at random as a starting point.}
            \item{Choose a destination point P at random from the VHash space.}
            \item{Use VHash routing to recursively seek the responsbile node R for p starting from N}
            \item{Calculate the closest node C to P.}
            \item{If C == R then register a hit}
            \item{Otherwise register a miss}
\end{enumerate}

\subsubsection{Experimental Results}
Results describe a curve of fast growth in hit-rate then convergance a a hitrate of 1.0.
As the network size and number of dimensions increase, convergence slows.
%pictures here


% Hop distance test
\subsection{Latency Distribution Test}
In this experiment we are primarilly concerned with VHash's ability to actively lower latency.
We considered it important to examine how latency generated by the network is distributed to examine where VHash is making improvments.
We use Chord as a DHT representative of O(log(n)) lookup topology.

Rather than examine the number of hops on the overlay network as our primary metric like previous works, we are concerned with the latency taking the properties of the underlay network into account.
Our unit of latencty is "hops on the underlay".
We generate a 10,000 node Scale Free Network (approximate diameter of 3) of which a subset are selected to act as members of the DHT.
We have no basis by which to assign latency values to each edge on the underlay network, so we measure latency in terms of hops on this underlay network.
VHash generates an embeding of the latency graph utilizing the distributed spring model algorithim described above.

\subsubsection{Experimental Results}
VHash has significantly shorter lookup latency then the chord graph with smaller variation in latency.
Both are generally worse than the real network diameter of 3.
As the size of the network increases, the accuracy of the graph embedding falls (as scale free graphs difficult to embed.)
%pictures here

\subsection{Conclusions}
In general, in similar circumstance we converge faster than Ray-Net.
Convergence rate varies with network size and number of dimensions of the VHash space.
Utilizing the current latency-embedding technique VHash is usefull for building DHT networks of reasonable size.

\section{Related Work}
While previous work has been done on applying Voronoi regions to DHTs and P2P applications, we have found no prior work on how to perform embedding of an inter-node latency graph.   

Backhaus et. al's  VAST \cite{Backhaus:2007:VAS:1326257.1326266} is a Voronoi-based P2P protocol designed for handling event messages in a massively multiplayer online videogame.  
Each node finds its neighbors by constructing a Voronoi diagram using Fortune's sweepline algorithm \cite{fortune1987sweepline}.  
VAST demonstrated that Voronoi diagrams could be used as the backbone  large-scale, although their work focused specifically on using 2-dimensional Voronoi diagrams.  
VHash approximates the Voronoi region rather than solving it, as higher dimension Voronoi regions are computationally expensive to solve.
In addition, VHash is designed to exploit network metrics.

The two DHT protocols developed by Beumont et al., VoroNet \cite{voronet} and RayNet \cite{raynet} are the closest comparisons to VHash.
VoroNet is based off Kleinberg's small world model \cite{kleinberg2000navigation} and achieves polylogarithmic lookup time.  
Each node in Voronet solves its Voronoi region to determine its neighbors and also maintains a link to a randomly chosen distant node.
Voronet focused specifically on the two-dimensional Vornoi computations and the techniques used would be too expensive in higher dimensions and were not resiliant to churn  \cite{raynet}.

RayNet \cite{raynet} was based on the work done on Voronet and is by far the most similar to VHash.  
Like VHash, RayNet does not solve for Voronoi regions, as that is prohibitively expensive.  
Whereas VHash uses a Distributed Greedy Voronoi Heuristic to find the neighbors that correspond with a node's Delaunay Triangulation,  RayNet uses a Monte-Carlo method to approximate the volume of a node's Voronoi region.  
While effective and estimating the Voronoi region,  the volume-based Monte-Carlo approximation is expensive and requires multiple samples. 
RayNet does mention the idea of mapping attributes to each axis, but how this can be exploited is left as future work.



 

\section{Future Work}

\bibliographystyle{ieeetr}
\bibliography{P3DNS}
\end{document}
