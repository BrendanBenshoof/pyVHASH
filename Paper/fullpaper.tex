\documentclass{IEEEtran}

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
%\usepackage{geometry}
%\geometry{letterpaper}
%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.



\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{url}
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{algorithm} 
\usepackage{algorithmic}
\usepackage{amsmath}



% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
%\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
%\pagestyle{fancy} % options: empty , plain , fancy
%\renewcommand{\headrulewidth}{0pt} % customise the layout...
%\lhead{}\chead{}\rhead{}
%\lfoot{}\cfoot{\thepage}\rfoot{}

%%% END Article customizations

%%% The "real" document content comes below...

\title{VHash: A Voronoi-Based Multidimensional Distributed Hash Table}
\author{Double Blind}
%\author{Brendan Benshoof \qquad Andrew Rosen  \\Department of Computer Science, Georgia State University\\  bbenshoof@cs.gsu.edu \qquad rosen@cs.gsu.edu }
\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\begin{abstract}
%1. State the problem
Distributed Hash Tables are used as a tool to generate overlay networks for P2P networks. Current DHT techniques are not designed to take the nature of the underlying network into account when organizing the overlay network. Current DHT networks assign nodes locations in a ring or tree, limiting the ability of these networks to be more efficient.
%2. Say why itâ€™s an interesting problem
A DHT technique that allows for efficient construction of an overlay network that takes into account the real underlying network would allow for higher performance and faster P2P networks.
%3. Say what your solution achieves
We present VHash as a spacial DHT based on approximate Delaunay Triangulation to integrate distance information between nodes into overlay network topology.
%4. Say what follows from your solution
VHash allows for the creation of P2P networks with faster record lookup time, storage, and maintenance with a geographically diverse set of nodes.

\end{abstract}
\section{Introduction}
A Distributed Hash Table is used provide an overlay network for many P2P applications. State of the art DHT techniques are built on trees or $\log$-ring structures to ensure that the routing distance is $O(lg(n))$ hops between nodes. 

In the vast majority of Distributed Hash Tables, such as Chord \cite{chord}, Kademlia\cite{kademlia}, Pastry \cite{pastry}, a node is mapped key on a 1-dimensional keyspace.  This key is chosen via a hash function, such as SHA-1, ensuring that nodes are randomly and uniformly the overlay network.
This provides the network with fault tolerance; if all the nodes located in a real geographic region were suddenly taken offline, the damage to the network would be spread uniformly throughout the network and maintenance would repair the damage.  
These topologies, while sufficient in reasonably local networks, do not take embed the lengths or latencies of routes defined by the topology and assume that every hop has similar latency and throughput. For a global network, a more intelligent means of generating a dynamic overlay network with efficient routing, storage, and backups is needed for future P2P applications.
 
%establish that we're orking in a higher dimensional space don't let d happedn
%We want to extend this to d dimensional
We present VHash as a DHT designed to take inter-node latency information into account when generating an overlay on a massive scale.  VHash creates an approximation of a Voronoi network to define the routing tables and dictate where content is stored in the network.  We accomplish this by assigning each node $d$ coordinates, rather than than a single key.  The naive method of doing so is to assign coordinates to servers based on the geographic location of nodes. More complex approaches approximate a minimum latency space based on internode latency. VHash can be considered  a generalized extension of VoroNet \cite{voronet} and  RayNet \cite{raynet}.

%Since no spacial information is embedded in the key, the routing tables and algorithms of DHTs aim to minimize the number of hops in order to route quickly.
%VHash is generalization of ring-based DHTs like Chord \cite{chord}, Pastry , and Symphony from 1-dimensional keyspaces to keyspaces with any number of dimensions.  

%Rather than focus on minimizing the amount of hops required to travel from point to point we wish to minimize the time required for a message to reach its recipient. VHash actually has a worse worst case hop distance ($O(\sqrt[d]{n})$)\footnote{Proof? It may be polylogarithmic} than other comparable distributed hash tables ($O(lg(n))$). However, VHash can route messages as quickly as possible rather than traveling over a grand tour that an overlay network may describe in the real world.

 

Our paper presents the following:
\begin{itemize}
	\item We present the algorithms that are used to approximate the Voronoi region and demonstrate that these approximations are accurate and sufficient enough to efficiently route between arbitrary nodes.
	\item We show how VHash can be used to create a robust, fault-tolerant file-sharing service.
	\item We created a simulation of our protocol and compared it to previous Voronoi based algorithms.
	\item We present the related work and how VHash improves upon the previous work and identify future areas of fruitful research.
\end{itemize}


\section{VHash}
Voronoi diagrams define ownership of a space, with each object in the space owning all the points closest to it.  We denote the region owned by an object as a Voronoi region, or simply that object's region.  In VHash, these objects are nodes mapped to a $d$-dimensional toroidal space and the regions they own define the range of keys they are responsible for.  \footnote{If Chord defined node responsibility in terms of distance to the key, Chord would be a 1-dimensional Voronoi diagram}.  

By assigning nodes and files a set of coordinates composed of not only the hashkey, but information that can be used as a metric for routing,  allows us to optimize routing in the the network along that metric without jeopardizing the distributed quality of the network.  We are particularly interested in embedding latency as a measurement of true distance between nodes.  Algorithm \ref{latency} describes the process for performing a minimum latency embedding using VHash.


A Voronoi diagram is the division of a $d$-dimensional space into cells or regions along a set of objects $O$ such that all the points in a particular region are closer to one object than any the object.  
We refer to the region owned by an object as that object's Voronoi region.
The Delaunay Trangulation of this same space along the same set of objects is defined by the edges such that no object is inside the circumcircle of any triangle formed by the edges\cite{geoalg}.  
The Voronoi diagram and Delaunay Triangulation are dual problems, as an edge between two objects in a Delaunay Triangulation exists iff those object's Voronoi region border each other.  
This means that solving either problem will yield the solution to both. 

In our network, the nodes are the objects of the Voronoi diagram and their regions define the keyspace they are responsible for.  The edges created by the Deluanay Triangulation correspond to the connections between neighboring nodes.  However, computing Voronoi diagrams is expensive, but a greedy approximation of the Voronoi regions is sufficient for the protocol.  We created a new greedy, online algorithm that approximates and maintains the set of peers defining the node's Voronoi region and Delaunay Triangulation.

A formal and thorough description of Voronoi diagrams as well as their applications can be found in \cite{aurenhammer1991voronoi}.





\begin{algorithm}
\caption{VHash Minimum Latency Embedding}
\label{latency}
\begin{algorithmic}[1]  % the number is how many 
	\STATE $d$ is the dimensions of the hash space
    \STATE seed the space with $d+1$ nodes at random locations
   	\STATE A node $n$ wishes to join the network
    \STATE $n$ pings a random subset of peers to find latency $L$
    \STATE Normalize $L$ onto (0.0,1.0) to yield $L_N$
    \STATE Choose position $p$ that minimizes \[\sum\limits_{i\in peers}(L_N[i]-dist(p,i))^2\] 
    \STATE Re-evaluate location periodically
\end{algorithmic}
\end{algorithm}






\subsection{Key Generation - Mapping a Node to Coordinates}

We suggest using the following spaces as our dimensions

\subsubsection{Cryptographic Keyspace}


\subsubsection{Geographic Coordinate}

\subsubsection{Latency - Spring Based Model}

\subsubsection{Security/Trust Space}

\subsubsection{Social Network Influence as an attribute.}

\subsubsection{Handling Files}





\subsubsection{Memory Overhead}
In order to route, a node maintains a routing table consisting of the nodes it borders a region with.  Unlike other DHTs, which keep routing tables of a set size, VHash's routing table depends on the nodes that it shares a border with, which is on average $3^d -1$???


 
\subsubsection{Toroidal Distance Equation}
VHash maps nodes to a $d$ dimension toroidal unit space overlay. This is essentially a hypercube with wrapping edges. The toroidal property makes visualization difficult but allows for a space without a sparse edge, as all nodes can translate the space such that they are at the center of the space.  In effect, each node views itself at the center of the graph.

As VHash uses multiple dimensions, responsibility for a key is assigned to the node closest to that key. Given two vector locations $\vec{a}$ and $\vec{b}$ on a  $d$ dimensional unit toroidal hypercube, the distance between them is:
\[  \sqrt[d]{\sum\limits_{i\in d} (\min(|\vec{a}_i-\vec{b}_i|, 1.0-|\vec{a}_i-\vec{b}_i|))^2}\]



%As mention previously,  VHash nodes are responsible for the address space defined by their Voronoi region. This region is defined by a list of peer nodes maintained by the node. A minimum list of peers is maintained such that the node's Voronoi region is well defined. The links connecting the node to its peers correspond to the links of a Delaunay Triangulation.  One such possible network is shown on Figure \ref{churninit}.


\begin{figure}
    \includegraphics[width=\linewidth]{voronoi-churn2}
    \caption{The starting network topology.  The blue lines demark the Voronoi edges, while the red lines connecting the nodes correspond to the Delaunay Triangulation edges and one-hop connections.}
    \label{churninit}
\end{figure}

\subsection{Approximation Algorithm}

VHash does not strictly solve Voronoi diagrams \cite{voronoi} for two reasons.  First, the toroidal nature of the space preclude the traditional means of solving for Voronoi regions. Second, computing a Voronoi diagram in spaces where $d \geq 3$ is prohibitively expensive \cite{raynet}\footnote{They cite Geometric Algorithms by Boissonat} and most of the efficient algorithms concern themselves with obtaining a Voronoi diagram of the entire space, rather than from the perspective of a distributed network, with each member calculating its own region. Rather than attempt to calculate the Voronoi region of each node, our algorithm simply filters locations, assigning responsibility to the nearest node. 


Each cycle, nodes exchange their peerlists with their current neighbors and then recalculate their neighbors.  
The calculation is straightforward.  After a node receives it's neighbor's peerlists, it combines their peerlists and its own into a list of candidate neighbors, sorted the nodes by distance from closest to furthest (using the distance metric from REF).  A new peerlist is then created starting with the first candidate from the list of candidates.  The node then looks at each of the remaining candidates and calculates the midpoint between the node and the candidate.  If any of the nodes in the new peerlist are closer to the candidate, the candidate is set aside.  Otherwise the candidate is added to the new peerlist.

%compare to richard's fast algorithm

To reduce the effects of nodes occluding one another when they are clustered together, each node maintains at minimum $3d+1$ neighbors.  If the node has remaining slots left over after creating a new peerlist\footnote{This is what raynet did,worked for them, will it work for us?}, the remaining slots are filled up the closest remaining candidates.


\begin{algorithm}
\caption{VHash Greedy Peer Selection}
\label{peer}
\begin{algorithmic}[1]  % the number is how many 
	\STATE $Candiates$ is the set of candidate peers
    \STATE $Peers$ is the set of this node's peers
    \STATE $Canidates$ is sorted by each node's closeness to this node
    \STATE The closest member of $Canidates$ is popped and added to $Peers$
    \FORALL{$n$ in $Canidates$}
    	\STATE $c$ is the midpoint between this node and $n$
        \IF{Any node in $Peers$ is closer to $c$ than this node}
        	\STATE reject $n$ as a peer
        \ELSE
        	\STATE Add $n$ to $Peers$
        \ENDIF
    \ENDFOR
\end{algorithmic}
\end{algorithm}


%\subsubsection{Why this approximation works}
By finding the correct (enough) neighbors, a node is able to approximate its local Voronoi region close enough for routing
If a node can figure out its Delaunay neighbors, it can extrapolate the Voronoi region (ie the region it's responsible for) from that. 


\subsection{Algorithm Analysis}
VHash's Voronoi approximation is extremely Efficient, in both terms of space and time.  Suppose a node is creating a peerlist from $k$ candidates to choose from.  The candidates must be sorted, which takes $O(k\cdot\lg(k))$ operations.  Then for each candidate, that the node must compute the midpoint between itself and the current candidate and then compare distances to that point between itself and all of the peers it has found so far.  This comes down to a cost of 

\[ k\cdot\lg(k) + k \text{ midpoint computations}  + k^{2} \text{ distance computations} \]



Since the largest $k$ can be is  $6d$  (the maximum number of unique stored neighbors allowed between two neighbors), we can translate the above to

\[6d\cdot\lg(6d) + 6d \text{ midpoint computations}  + (6d)^{2} \text{ distance computations}\]


Since $k$ is dependent only on the number of dimensions, $d$, $k$ itself is constant and the algorithm runs in constant time with a small coefficient.  This is a very large improvement over the volume approximation used by Raynet \cite{raynet}, which required 1000 distance calculates to do a Monte-Carlo approximation of the Voronoi region.  The routing tables will have a minimum size of $3d+1$ but have an unbounded maximum size. 

How large can the routing table get?  It is theoretically possible to create a network in which a single node is the neighbor of every other node in the network, but it is highly unlikely. The \textit{expected maximum degree} of an object in a $d$-dimensional Delaunay Triangulation in a network of size N is $\Theta(\frac{\log N}{\log \log N} )$ \cite{bern1991expected}.


\subsubsection*{Accuracy}

The key to the greedy approximation working is that it just needs to be accurate to route.  A node will not falsely believe that it owns a particular key; a key not belonging to it will always fall into the domain of some peer and be closer to that peer or another node that the peer knows of.


The routing tables in VHash are $O(1)$ space, while providing polylogarithmic  average lookup time measured in hops?\footnote{Our initial assessment was $d$-root, but other papers say Polylogarithmic routing \cite{kleinberg2000navigation} \cite{raynet}} average lookup time in hops with a minimized latency.



The \textit{expected maximum number of peers} the ,\footnote{This is maximum number of peers that a node would have in a non-contrived example.  While the degree for a node can theoretically be $O(n)$ in a Delaunay triangulation, it is extremely unlikely.}


Avg. Node degree is the average degree of a point in a $d$-dimensional toroidal space.  
Consider a $d$-dimensional toroidal space.  Let some arbitrary point $A$ be the center of this space\footnote{Any point in a toroidal space can view itself as it's center}.  A hypercube that surrounds the space would be defined by $3^d -1$ points citation \footnote{Is this rigorous enough?}






\subsection{Routing}
\subsubsection{Messages}
Maintenance and joining are handled by a simple periodic mechanism. A notification message consisting of a node's information and active peers is the only maintenance message. All messages have a destination hash location which is used to route them to the proper server. This destination can be the hash location of a particular node or the location of a desired record or service.  The message is received by the node responsible for the location. Services running on the DHT define their own message contents, such as commands to store and retrieve data.

\subsubsection{Message Routing}
Messages are routed over the overlay network using a simple algorithm ( Algorithm \ref{routing}). 
When routing a message to an arbitrary location, a node calculates who's Voronoi region the message's destination is in amongst the itself and its peers. If the destination falls within its own region, then it is responsible and handles the message accordingly. Otherwise, the node forwards the message to the closest peer to the destination location. This process describes\footnote{Wording.  Is equivalent a better word?} a pre-computed and cached A* routing  algorithm \cite{astar} . 

\begin{algorithm}
\caption{Vhash Routing}
\label{routing}
\begin{algorithmic}[1]  % the number is how many 
	\STATE $P_0$ is this node's set of peers
    \STATE $N$ is this node
	\STATE $m$ is a message addressed for $L$
    \STATE $Forwards$ is the set $P_0\cup{}N$
    \STATE find $C$: member of $Forwards$ which has the shortest distance to $L$
    \IF{$C$ is $N$}
    	\STATE $N$ is the responsible party.
        \STATE Handle $m$
    \ELSE
    	\STATE Forward $m$ to $C$ for handling or further routing
    \ENDIF
\end{algorithmic}
\end{algorithm}


\subsubsection{Provided Routing Time}

%\subsubsection{Andrew's random thought for fault tolerance with routing}
%If a node thinks it's responsible for some key, but it turns out not to be the case,  we can redirect the message to the node next closest (with a flag in the message to prevent loops). 



\subsection{Joining and Maintenance}
Joining the network is a straightforward process. A new node first learns the location of at least one member of the network to join. The joining node then chooses a location in the hash space either at random or based on a problem formulation (for example, based on geographic location or latency information).

After choosing a location, the joining node sends a ``join'' message to its own location via the known node.
The message is forwarded to the current owner of that location who can be considered the ``parent'' node.
The parent node immediately replies with a maintenance message containing its full peer list. This message is sent to the joining node, who then uses this to begin defining the space it is responsible for. 

The joining node's initial peers are a subset of the parent and the parent's peers. The parent adds the new node to its own peer list and removes all his peers occluded by the new node.  Then regular maintenance propagates the new node's information and repairs the overlay topology.  This process is enumerated by Algorithm \ref{join}.


\begin{algorithm}
\caption{Vhash Join}
\label{join}
\begin{algorithmic}[1]  % the number is how many 
\STATE new node $N$ wishes to join and has location $L$
\STATE $N$ knows node $x$ to be a member of the network
\STATE $N$ sends a request to join, addressed to $L$ via $x$
\STATE node $Parent$ is responsible for location $L$ and receives the join message
\STATE $Parent$ sends to $N$ its own location and list of peers
\STATE $Parent$ integrates $N$ into its peer set
\STATE $N$ builds its peer list from $N$ and its peers
\STATE regular maintenance updates other peers
\end{algorithmic}
\end{algorithm}




Each node in the network performs maintenance periodically by a maintenance message to its peers. The maintenance message consists of the node's information and the information on that node's peer list. When a maintenance message is received, the receiving node considers the listed nodes as candidates for its own peer list and removes any occluded nodes (Algorithm \ref{peer}). 

When messages sent to a peer fail, it is assumed the peer has left the network. The leaving peer is removed from the peer list and candidates from the set of 2-hop peers provided by other peers move in to replace it.  Maintenance is described by Algorithms \ref{maint} and \ref{handlemaint}.  Figures \ref{churnjoin}, \ref{churndone}, and \ref{churndrop} illustrate the joining processing.

\begin{algorithm}
\caption{VHash Maintenance Cycle}
\label{maint}
\begin{algorithmic}[1]  % the number is how many 
	\STATE $P_0$ is this node's set of peers
    \STATE $T$ is the maintenance period
    \WHILE{Node is running}
    	\FORALL{node $n$ in $P_0$}
        	\STATE Send a Maintenance Message containing $P_0$ to $n$
        \ENDFOR
    \STATE Wait $T$ seconds
    \ENDWHILE
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{VHash Handle Maintenance Message}
\label{handlemaint}
\begin{algorithmic}[1]  % the number is how many 
	\STATE $P_0$ is this node's set of peers
	\STATE Receive a Maintenance Message from peer $n$ containing its set of peers:$P_n$
    \FORALL{Peers $p$ in $P_n$}
    	\STATE Consider $p$ as a member of $P_0$
        \IF{$p$ should join $P_0$}
        	\STATE Add $p$ to $P_0$
            \FORALL {Other peers $i$ in $p$}
            	\IF{$i$ is occluded by $p$}
                	\STATE remove $i$ from $P_0$
                \ENDIF
            \ENDFOR
        \ENDIF
    \ENDFOR
\end{algorithmic}
\end{algorithm}

There is no function for a "polite" exit from the network. VHash  assumes nodes will fail and the difference between an intended failure and unintended failure is unnecessary. The only issue this causes is that node software should be designed to fail totally when issues arise rather then attempt to fulfill only part of its responsibilities.  


\begin{figure}
    \includegraphics[width=\linewidth]{voronoi-churn4}
    \caption{Here, a new node is joining the networks and has established that his position falls in the the yellow shaded Voronoi region.}
    \label{churnjoin}
\end{figure}


\begin{figure}
    \includegraphics[width=\linewidth]{voronoi-example}
    \caption{The network topology after the new node has finished joining.}
    \label{churndone}
\end{figure}

\begin{figure}
    \includegraphics[width=\linewidth]{voronoi-churn1}
    \caption{The topology immediately after the new node leaves the network. After maintenance takes place, the topology repairs itself back to the configuration shown in Figure \ref{churninit}.}
    \label{churndrop}
\end{figure}


\subsection{Data Storage and Backups}
The primary goal of a DHT is to provide a distributed storage medium. We extend this idea to distribute work and information among nodes using the same paradigm. Resources in the network, be it raw data or assigned tasks, are assigned hash locations. The node responsible for a given hash location is responsible for the maintenance of that resource. When a node fails, its peers take responsibility of its space. Thus it is important to provide peers with frequent backups of a node's assigned resources.  That way, when a node fails, its peers can immediately assume its responsibilities.

When a resource is to be stored on the network, it is assigned a hash location. The hash locations assigned could be random, a hash of an identifier, or have specific meaning for an embedding problem. The node responsible for that resource's hash location stores the resource.

A resource is accessed by contacting the node responsible for the resource.  However, the requester generally has no idea which node is responsible for any particular resource.  The data request messsage is addressed to the location corresponding to the resource, rather than the node responsible for that location.  The message is forwarded over the overlay network, each hop bringing the node closer until it reaches the responsible node, who sends the resource or an error if the resource does not exist.

Some options are immediately apparent for dealing with wasted storage space. A system that is primarily read driven can record the time of the last read or a frequency of reads such that resources that are not read often enough are deleted after a certain period of time. If a system is write driven, allow the resource to be assigned a time to live, which can be updated as needed.

A node periodically sends a message containing backups of the resources for which it became newly responsible for to each of its peers. To minimize bandwidth and time wasted by backups, the node should only send the records changed since last backup.


\subsection*{Fault Tolerence}
That's what the long hops are for.

\subsection{Peerlist Details}



\subsection{Error Analyis}
%What is the error of the Voronoi Region and Delaunay Triangulation.
Error in the graph results from occlusion (example).  We allivate this with a minimum short peer size and using long peers.

\section{Simulations}
We simulated VHash to acertain the protocol's performance. 


\subsection{Routing Completeness}

We began by creating a large underlay network.  Then $n$ random nodes were chosen to join the overlay \footnote{Can we used the number of underlay hops as out ``latency dimension'' here? }.  Nodes in the suimulation would route a message to one another and we plotted the latency and successful deliveries for VHash and Raynet.  Latency was measured by the number of hops in the \textit{underlay} network.  For comparison we also compared the performance if messages were routed perfectally and optimally to see how close to the ideal our performance was. 


\subsubsection*{What we didn't show and why}
A non chaotic starting point because that was no challenge, chatty join was immediately converegent

\subsubsection*{What we didn't test and why}

\subsection{Latency}
%Comparison with chord, hop lengths were logarithmic

\subsection{Hop Details}


\section{Related Work And Future}
Voronet stuff here.


Beaumont \textit{et al} \cite{raynet}  argues that a loose structure enough for searching.  Assume a $d$-dimension space, each dimension tied to some attribute of an object and each object identified by a unique set of values.  Objects should be linked to other objects that are close in the space.
 

The key insight that Beaumont \textit{et al} had  was that nodes only needed to calculate their regions locally and this can be done via goosip-based protocol.

Each node maintains a \textit{view}, the closest $3d+1$ neighbors it knows of and periodically exchanges information with them.


Pastry also tried to address this problem.

%\begin{itemize}
%	\item Assignment of keys and responsibility.  IN Chord it is the successor, Pastry is closest to id.
%	\item Pastry's locality heuristic assumes Euclidean space, namely triangle equality holds.  How do we get around that.   Pastry also assumes magic distance function is provided to determine distance between two nodes, however distance is not embedded in the keyspace (which is randomly distributed) but rather the ``proximity space''  built off of bootstrapped assumetions (node we are using to joining the ring is close to the joining node in the proximity space, and the proximity assumptions for a network were good prior to the join operation.  The key idea is that at each hop messages travel closer to the destination, while minimizing the metric distance traveled  (such as num hops).  Expected distance traveled grows exponentially with each hop.  their results showed that the metric distance traveled by routed message over pastry was 30\%-40\% greater than the distance between the source and destination.  Has to uyse second stage when joining to maintain locality.  Total join cost in messages is $\approx 3 \cdot 2^b \cdot \log_{2^{b}} N $
%\end{itemize}

Apply this to MANET.


\bibliographystyle{ieeetr}
\bibliography{P3DNS}
\end{document}